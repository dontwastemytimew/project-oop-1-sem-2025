#ifndef MATCHENGINE_H
#define MATCHENGINE_H

#include "UserProfile.h"
#include "DatabaseManager.h"
#include <QList>

/**
 * @brief Клас для обчислення сумісності між користувачами.
 *
 * Цей клас відповідає за бізнес-логіку "матчингу" (пошуку пари).
 * Він аналізує два профілі користувачів та визначає, наскільки вони підходять один одному
 * на основі набору критеріїв: стать, орієнтація, вік, місцезнаходження та спільні інтереси (теги).
 *
 * @note Клас не зберігає дані, а лише обробляє їх, використовуючи DatabaseManager для отримання додаткової інформації (наприклад, тегів).
 */
class MatchEngine {
public:
    /**
     * @brief Конструктор MatchEngine.
     * @param dbManager Вказівник на менеджер бази даних для доступу до тегів та профілів.
     */
    explicit MatchEngine(DatabaseManager* dbManager);

    /**
     * @brief Перевіряє, чи є два профілі потенційно сумісними.
     *
     * Метод виконує "жорстку" перевірку критичних параметрів (наприклад, чи відповідає
     * стать партнера орієнтації користувача). Якщо базова сумісність відсутня,
     * подальший розрахунок відсотків не має сенсу.
     *
     * @param p1 Профіль першого користувача (зазвичай, той, хто шукає).
     * @param p2 Профіль другого користувача (кандидат).
     * @return true, якщо користувачі можуть бути парою (score > 0).
     * @return false, якщо є критична несумісність (наприклад, стать не підходить) або це один і той самий користувач.
     */
    bool isCompatible(const UserProfile& p1, const UserProfile& p2) const;

    /**
     * @brief Обчислює абсолютний бал сумісності.
     *
     * Використовує внутрішню систему балів:
     * - Збіг міста: +20 балів.
     * - Різниця у віці < 2 років: +20 балів.
     * - Різниця у віці < 6 років: +10 балів.
     * - Наявність біографії у обох: +5 балів.
     * - Збіг кожного тегу: +10 балів.
     * - Критична невідповідність орієнтації: -1000 балів.
     *
     * @param p1 Профіль першого користувача.
     * @param p2 Профіль другого користувача.
     * @return int Сумарна кількість балів (може бути від'ємною).
     */
    int compatibilityScore(const UserProfile& p1, const UserProfile& p2) const;

    /**
     * @brief Обчислює відсоток сумісності (0–100%).
     *
     * Нормалізує результат compatibilityScore() до шкали від 0 до 100.
     * Використовується для відображення користувачу ("Ви сумісні на 85%").
     *
     * @param p1 Профіль першого користувача.
     * @param p2 Профіль другого користувача.
     * @return int Відсоток сумісності (0-100).
     */
    int compatibilityPercent(const UserProfile& p1, const UserProfile& p2) const;

    /**
     * @brief Повертає відсортований список "Метчів" (взаємних лайків).
     *
     * Метод знаходить усіх користувачів, з якими у `userId` є взаємний лайк,
     * розраховує для кожного відсоток сумісності та сортує список від
     * найбільш сумісних до найменш сумісних.
     *
     * @param userId ID користувача, для якого формується список метчів.
     * @return QList<QPair<UserProfile, int>> Список пар {Профіль, Відсоток сумісності}.
     */
    QList<QPair<UserProfile, int>> getSortedMatches(int userId) const;

private:
    DatabaseManager* m_dbManager; ///< Посилання на базу даних для завантаження тегів та профілів.
};

#endif // MATCHENGINE_H